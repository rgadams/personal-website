!function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}__webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,(function(key){return value[key]}).bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s="VPKW")}({VPKW:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);class Matrix{constructor(matrix){this.matrix=matrix,this.rows=matrix.length,this.columns=matrix[0].length,matrix.forEach(row=>{if(row.length!=this.columns)throw new Error("Invalid matrix, not all columns of same size")})}static createBlankSquareMatrixFromDimensions(dim,identity=!1){let newMatrix=[];for(let i=0;i<dim;i++){let newColumn=[];for(let j=0;j<dim;j++)newColumn.push(identity&&i==j?1:0);newMatrix.push(newColumn)}return new Matrix(newMatrix)}static createBlankMatrix(n_rows,n_cols){let newMatrix=[];for(let i=0;i<n_rows;i++){let newColumn=[];for(let j=0;j<n_cols;j++)newColumn.push(0);newMatrix.push(newColumn)}return new Matrix(newMatrix)}static multiply(leftMatrix,rightMatrix){if(leftMatrix.columns!=rightMatrix.rows)throw new Error("Cannot multiply these two matrices together");const newMatrix=Matrix.createBlankMatrix(leftMatrix.rows,rightMatrix.columns);for(let i=0;i<leftMatrix.rows;i++)for(let j=0;j<rightMatrix.columns;j++){let sum=0;for(let k=0;k<leftMatrix.columns;k++)sum+=leftMatrix.matrix[i][k]*rightMatrix.matrix[k][j];newMatrix.matrix[i][j]=sum}return newMatrix}get(row,column){return this.matrix[row][column]}multiply(otherMatrix){return Matrix.multiply(this,otherMatrix)}transpose(){let newMatrix=Matrix.createBlankMatrix(this.columns,this.rows);for(let j=0;j<newMatrix.rows;j++)for(let i=0;i<newMatrix.columns;i++)newMatrix.matrix[j][i]=this.matrix[i][j];return newMatrix}isSquare(){return this.rows===this.columns}inverse(){if(!this.isSquare())throw new Error("Can't get inverse of non-square matrix!");let inverseMatrix=Matrix.createBlankSquareMatrixFromDimensions(this.rows);const determinant=Matrix.getDeterminant(this,this.rows);if(0==determinant)throw new Error("Matrix is singular, can't find inverse");const adjoint=Matrix.createBlankSquareMatrixFromDimensions(this.rows);Matrix.adjoint(this,adjoint);for(let i=0;i<this.rows;i++)for(let j=0;j<this.rows;j++)inverseMatrix.matrix[i][j]=adjoint.matrix[i][j]/determinant;return inverseMatrix}static adjoint(matrix,adj){if(1==matrix.rows)return void(adj.matrix[0][0]=1);let sign=1;const tempMatrix=Matrix.createBlankSquareMatrixFromDimensions(matrix.rows);for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.rows;j++)Matrix.getCofactor(matrix,tempMatrix,i,j,matrix.rows),sign=(i+j)%2==0?1:-1,adj.matrix[j][i]=sign*Matrix.getDeterminant(tempMatrix,matrix.rows-1)}static getCofactor(matrix,tempMatrix,p,q,n){let i=0,j=0;for(let row=0;row<n;row++)for(let column=0;column<n;column++)row!=p&&column!=q&&(tempMatrix.matrix[i][j++]=matrix.matrix[row][column],j==n-1&&(j=0,i++))}static getDeterminant(matrix,n){let d=0;if(1==n)return matrix.matrix[0][0];let tempMatrix=Matrix.createBlankSquareMatrixFromDimensions(matrix.rows),sign=1;for(let f=0;f<n;f++)Matrix.getCofactor(matrix,tempMatrix,0,f,n),d+=sign*matrix.matrix[0][f]*Matrix.getDeterminant(tempMatrix,n-1),sign*=-1;return d}}addEventListener("message",({data:data})=>{const result=Matrix.multiply(data.data.leftMatrix,data.data.rightMatrix);postMessage({result:result,dataIndex:data.dataIndex})})}});