(()=>{"use strict";class i{constructor(t){this.matrix=t,this.rows=t.length,this.columns=t[0].length,t.forEach(e=>{if(e.length!==this.columns)throw new Error("Invalid matrix, not all columns of same size")})}static createBlankSquareMatrixFromDimensions(t,e=!1){const s=[];for(let o=0;o<t;o++){const r=[];for(let n=0;n<t;n++)r.push(e&&o===n?1:0);s.push(r)}return new i(s)}static createBlankMatrix(t,e){const s=[];for(let o=0;o<t;o++){const r=[];for(let n=0;n<e;n++)r.push(0);s.push(r)}return new i(s)}static multiply(t,e){if(t.columns!==e.rows)throw new Error("Cannot multiply these two matrices together");const s=i.createBlankMatrix(t.rows,e.columns);for(let o=0;o<t.rows;o++)for(let r=0;r<e.columns;r++){let n=0;for(let a=0;a<t.columns;a++)n+=t.matrix[o][a]*e.matrix[a][r];s.matrix[o][r]=n}return s}static adjoint(t,e){if(1===t.rows)return void(e.matrix[0][0]=1);let s=1;const o=i.createBlankSquareMatrixFromDimensions(t.rows);for(let r=0;r<t.rows;r++)for(let n=0;n<t.rows;n++)i.getCofactor(t,o,r,n,t.rows),s=(r+n)%2==0?1:-1,e.matrix[n][r]=s*i.getDeterminant(o,t.rows-1)}static getCofactor(t,e,s,o,r){let n=0,a=0;for(let l=0;l<r;l++)for(let c=0;c<r;c++)l!==s&&c!==o&&(e.matrix[n][a++]=t.matrix[l][c],a===r-1&&(a=0,n++))}static getDeterminant(t,e){let s=0;if(1===e)return t.matrix[0][0];const o=i.createBlankSquareMatrixFromDimensions(t.rows);let r=1;for(let n=0;n<e;n++)i.getCofactor(t,o,0,n,e),s+=r*t.matrix[0][n]*i.getDeterminant(o,e-1),r*=-1;return s}get(t,e){return this.matrix[t][e]}multiply(t){return i.multiply(this,t)}transpose(){const t=i.createBlankMatrix(this.columns,this.rows);for(let e=0;e<t.rows;e++)for(let s=0;s<t.columns;s++)t.matrix[e][s]=this.matrix[s][e];return t}isSquare(){return this.rows===this.columns}inverse(){if(!this.isSquare())throw new Error("Can't get inverse of non-square matrix!");const t=i.createBlankSquareMatrixFromDimensions(this.rows),e=i.getDeterminant(this,this.rows);if(0===e)throw new Error("Matrix is singular, can't find inverse");const s=i.createBlankSquareMatrixFromDimensions(this.rows);i.adjoint(this,s);for(let o=0;o<this.rows;o++)for(let r=0;r<this.rows;r++)t.matrix[o][r]=s.matrix[o][r]/e;return t}}addEventListener("message",({data:u})=>{const s=i.multiply(u.data.leftMatrix,u.data.rightMatrix);postMessage({result:s,dataIndex:u.dataIndex})})})();